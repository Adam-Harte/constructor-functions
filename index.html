<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="app.js"></script>
    <title>Constructor Functions</title>
  </head>
  <body>
    <h1>Constructor Functions</h1>
    <p>
      Constructor functions are a way for us to define blueprints for objects
      with methods and prooerties the same way we use classes and also the same
      way we define them with the new keyword used to create instances. Behind
      the scenes classes are converted to these constructor functions as this is
      the original method that existed to create object blueprints before the
      class syntax was available.
    </p>
    <h3>Prototypes</h3>
    <p>
      Prototypes are connected objects in JavaScript wihc act as fallbakcks for
      objects. JavaScript uses prototypal inheritance meaning objects inherit
      prototypes from the classes/objects they extend starting from the global
      Object, then type objects e.g. Array, String etc. and so on. You can see
      prototypes of objects via the __proto__ property. Constructor functions
      also have a prototype property which points to the exact same object in
      memory as __proto__ and is used to define a new prototype and therefore
      overrite the __proto__ for every object we create based on that
      constructor function.
    </p>
    <h3>Methods in Classes vs Constructor Functions</h3>
    <p>
      When we define methods in a class with the shorthand syntax of parenthesis
      and function body without assinging it with '=' JavaScript automatically
      does an optimization for us by adding that method as part of the prototype
      of that class instead of as a property/method of the instances. This gives
      us a performance benefit as now this method is only defined once in the
      prototype instead of a new function object being created for every
      instance of the class. We typically only ever need methods stored in the
      prototype as they interact normally with dynamic data of the object
      instances with the 'this' keyword. Constructor Functions on the other hand
      dont automatically add methods to the prototype and so instead to get the
      same performance benefit we must define the method on the prototype object
      e.g. function.prototype.method. The time an instance method would be
      preferred is when we need to bind methods of a class to the correct 'this'
      context such as with event listeners so we can instead define an arrow
      function.
    </p>
    <h3>Getting and Setting Prototypes</h3>
    <p>
      The global Object prototype has methods for getting and setting prototypes
      to objects. Object getPrototypeOf takes an object as an argument and will
      then return the prototype of that object. Object setPrototypeOf takes an
      object as an argument and also a new object which will be set as the
      prototype for that first object argument. These methods are useful for
      getting and setting prototypes of instantiated objects where we maybe dont
      want to change the prototype of the base class/object itself. There is
      also an Object create method which creates an empty object that however
      takes an argument object which becomes the new objects prototype.
    </p>
  </body>
</html>
